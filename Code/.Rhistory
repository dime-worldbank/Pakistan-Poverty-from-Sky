"Top Crash Clusters",
"Individual Crashes"),
options = layersControlOptions(collapsed = FALSE))
# Parameters
near_crash_thresh_km <- 0.1
near_anycrash_in_cluster_thresh_km <- 0.3
# Load and Prep Data -----------------------------------------------------------
police_all_df <- read.csv(file.path(project_file_path, "Data", "FinalData", "Police Data", "police_digitized.csv"), stringsAsFactors=F)
# Remove obs with no coords and far away coords
police_all_df <- police_all_df[!is.na(police_all_df$latitude),]
# smarTTrans Master
# Filepaths --------------------------------------------------------------------
if(Sys.info()[["user"]] == "WB521633") project_file_path <- "C:/Users/wb521633/Dropbox/World Bank/IEs/CrashMap-Nairobi"
if(Sys.info()[["user"]] == "robmarty") project_file_path <- "~/Dropbox/World Bank/IEs/CrashMap-Nairobi"
if(Sys.info()[["user"]] == "WB521633") code_file_path <- "C:/Users/wb521633/Documents/Github/CrashMap-Nairobi"
if(Sys.info()[["user"]] == "robmarty") code_file_path <- "~/Documents/Github/CrashMap-Nairobi"
rawdata_file_path <- file.path(project_file_path, "Data", "RawData")
finaldata_file_path <- file.path(project_file_path, "Data", "FinalData")
algorithm_inputs <- file.path(project_file_path, "Data", "FinalData", "Twitter Algorithm Inputs")
tables_file_path <- file.path(project_file_path, "Papers", "Algorithm", "Tables")
figures_file_path <- file.path(project_file_path, "Papers", "Algorithm", "Figures")
# Packages ---------------------------------------------------------------------
library(leaflet)
library(dplyr)
library(rgdal)
library(rgeos)
library(data.table)
library(lubridate)
library(ggplot2)
library(raster)
library(sp)
library(sf)
library(spdep)
library(broom)
library(raster)
library(parallel)
library(pbmcapply)
library(stringr)
library(dplyr)
library(readxl)
library(haven)
library(doBy)
library(ggmap)
library(grid)
library(gridExtra)
library(gtable)
library(dplyr)
library(lubridate)
library(doBy)
library(ggplot2)
library(scales)
library(tidyr)
library(ggpubr)
library(wesanderson)
library(jcolors)
library(raster)
library(rgdal)
library(dplyr)
library(readr)
library(stringdist)
library(stringr)
library(dplyr)
library(quanteda)
library(caret)
library(stringr)
library(quanteda.classifiers) # devtools::install_github("quanteda/quanteda.svm")
source(file.path(code_file_path, "Code", "Twitter Geocode Algorithm", "code", "04_algorithm", "crashmap_algorithm.R"))
# Crash Clustering
# Parameters
near_crash_thresh_km <- 0.1
near_anycrash_in_cluster_thresh_km <- 0.3
# Load and Prep Data -----------------------------------------------------------
police_all_df <- read.csv(file.path(project_file_path, "Data", "FinalData", "Police Data", "police_digitized.csv"), stringsAsFactors=F)
# Remove obs with no coords and far away coords
police_all_df <- police_all_df[!is.na(police_all_df$latitude),]
police_all_df <- police_all_df[police_all_df$latitude > -2,]
police_all_df <- police_all_df[police_all_df$latitude < -1.1,]
police_all_df <- police_all_df[police_all_df$longitude < 37.5,]
# Sort by latitude & longitude
police_all_df <- police_all_df[order(police_all_df$latitude, police_all_df$longitude),]
# Cluster ----------------------------------------------------------------------
police_all_df$id <- 1:nrow(police_all_df)
police_all_df$cluster_id <- NA
for(i in 1:nrow(police_all_df)){
police_all_df_i <- police_all_df[i,]
within_distance <- sqrt((police_all_df_i$longitude - police_all_df$longitude)^2 + (police_all_df_i$latitude - police_all_df$latitude)^2) <= (near_crash_thresh_km/111.12)
# If has a cluster ID, consider giving cluster id
if(!is.na(police_all_df_i$cluster_id)){
# Check if all crashes in cluster are within threshold distance
current_cluster <- police_all_df[police_all_df$cluster_id %in% police_all_df_i$cluster_id,]
within_cluster_distance <- sqrt((police_all_df_i$longitude - current_cluster$longitude)^2 + (police_all_df_i$latitude - current_cluster$latitude)^2) <= (near_anycrash_in_cluster_thresh_km/111.12)
# If a crash is not within thresh distance, give ID as cluster; otherwise, add to cluster
if(FALSE %in% within_cluster_distance){
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$cluster_id
}
# If doesn't have cluster ID, give ID.
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
}
}
# Create Cluster Polygons ------------------------------------------------------
police_all_sp <- police_all_df
coordinates(police_all_sp) <- ~longitude+latitude
crs(police_all_sp) <- CRS("+init=epsg:4326")
clusters_sp <- lapply(unique(police_all_sp$cluster_id), function(cluster_id_i){
police_all_sp_i <- police_all_sp[police_all_sp$cluster_id == cluster_id_i,]
police_all_sp_i_hull <- gConvexHull(police_all_sp_i)
police_all_sp_i_hull <- gBuffer(police_all_sp_i_hull, width=0.00001)
police_all_sp_i_hull$id <- cluster_id_i
police_all_sp_i_hull$N <- nrow(police_all_sp_i)
return(police_all_sp_i_hull)
}) %>% do.call(what="rbind")
# Leaflet Map ------------------------------------------------------------------
clusters_sp <- clusters_sp[clusters_sp$N > 1,]
clusters_sp$text <- clusters_sp$N %>% as.character
clusters_sp_top <- clusters_sp[order(clusters_sp$N, decreasing=T),][1:30,]
pal <- colorNumeric(
palette = "Spectral",
domain = clusters_sp$N,
reverse=T
)
leaflet() %>%
addProviderTiles(providers$Esri.WorldTopoMap) %>%
addPolygons(data=clusters_sp,
color = ~pal(N),
fillOpacity=.9,
opacity=0.8,
stroke=T,
popup=~text,
group="Crash Clusters") %>%
addPolygons(data=clusters_sp_top,
color = "red",
fillOpacity=1,
opacity=1,
stroke=T,
popup=~text,
group="Top Crash Clusters") %>%
addCircles(data=police_all_sp,
stroke=F,
fillOpacity=0.4,
color="black",
weight=1,
group="Individual Crashes") %>%
addLayersControl(overlayGroups = c("Crash Clusters",
"Top Crash Clusters",
"Individual Crashes"),
options = layersControlOptions(collapsed = FALSE))
# Crash Clustering
# Parameters
near_crash_thresh_km <- 0.1
near_anycrash_in_cluster_thresh_km <- 0.3
# Load and Prep Data -----------------------------------------------------------
police_all_df <- read.csv(file.path(project_file_path, "Data", "FinalData", "Police Data", "police_digitized.csv"), stringsAsFactors=F)
# Remove obs with no coords and far away coords
police_all_df <- police_all_df[!is.na(police_all_df$latitude),]
police_all_df <- police_all_df[police_all_df$latitude > -2,]
police_all_df <- police_all_df[police_all_df$latitude < -1.1,]
police_all_df <- police_all_df[police_all_df$longitude < 37.5,]
# Sort by latitude & longitude
police_all_df <- police_all_df[order(police_all_df$latitude, police_all_df$longitude),]
# Clean Police Variables -------------------------------------------------------
police_all_df$fatal_injury_count[is.na(police_all_df$fatal_injury_count)] <- 0
police_all_df$serious_injury_count[is.na(police_all_df$serious_injury_count)] <- 0
police_all_df$slight_injury_count[is.na(police_all_df$slight_injury_count)] <- 0
police_all_df$injury_count <- police_all_df$slight_injury_count + police_all_df$serious_injury_count + police_all_df$fatal_injury_count
police_all_df$fatal_injury_pedestrian_count[is.na(police_all_df$fatal_injury_pedestrian_count)] <- 0
police_all_df$slight_injury_pedestrian_count[is.na(police_all_df$slight_injury_pedestrian_count)] <- 0
police_all_df$serious_injury_pedestrian_count[is.na(police_all_df$serious_injury_pedestrian_count)] <- 0
police_all_df$injury_pedestrian_count <- police_all_df$serious_injury_pedestrian_count + police_all_df$slight_injury_pedestrian_count + police_all_df$fatal_injury_pedestrian_count
police_all_df <- police_all_df[police_all_df$fatal_injury_pedestrian_count > 0,]
# Cluster ----------------------------------------------------------------------
police_all_df$id <- 1:nrow(police_all_df)
police_all_df$cluster_id <- NA
for(i in 1:nrow(police_all_df)){
police_all_df_i <- police_all_df[i,]
within_distance <- sqrt((police_all_df_i$longitude - police_all_df$longitude)^2 + (police_all_df_i$latitude - police_all_df$latitude)^2) <= (near_crash_thresh_km/111.12)
# If has a cluster ID, consider giving cluster id
if(!is.na(police_all_df_i$cluster_id)){
# Check if all crashes in cluster are within threshold distance
current_cluster <- police_all_df[police_all_df$cluster_id %in% police_all_df_i$cluster_id,]
within_cluster_distance <- sqrt((police_all_df_i$longitude - current_cluster$longitude)^2 + (police_all_df_i$latitude - current_cluster$latitude)^2) <= (near_anycrash_in_cluster_thresh_km/111.12)
# If a crash is not within thresh distance, give ID as cluster; otherwise, add to cluster
if(FALSE %in% within_cluster_distance){
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$cluster_id
}
# If doesn't have cluster ID, give ID.
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
}
}
# Create Cluster Polygons ------------------------------------------------------
police_all_sp <- police_all_df
coordinates(police_all_sp) <- ~longitude+latitude
crs(police_all_sp) <- CRS("+init=epsg:4326")
clusters_sp <- lapply(unique(police_all_sp$cluster_id), function(cluster_id_i){
police_all_sp_i <- police_all_sp[police_all_sp$cluster_id == cluster_id_i,]
police_all_sp_i_hull <- gConvexHull(police_all_sp_i)
police_all_sp_i_hull <- gBuffer(police_all_sp_i_hull, width=0.00001)
police_all_sp_i_hull$id <- cluster_id_i
police_all_sp_i_hull$N <- nrow(police_all_sp_i)
return(police_all_sp_i_hull)
}) %>% do.call(what="rbind")
# Leaflet Map ------------------------------------------------------------------
clusters_sp <- clusters_sp[clusters_sp$N > 1,]
clusters_sp$text <- clusters_sp$N %>% as.character
clusters_sp_top <- clusters_sp[order(clusters_sp$N, decreasing=T),][1:30,]
pal <- colorNumeric(
palette = "Spectral",
domain = clusters_sp$N,
reverse=T
)
leaflet() %>%
addProviderTiles(providers$Esri.WorldTopoMap) %>%
addPolygons(data=clusters_sp,
color = ~pal(N),
fillOpacity=.9,
opacity=0.8,
stroke=T,
popup=~text,
group="Crash Clusters") %>%
addPolygons(data=clusters_sp_top,
color = "red",
fillOpacity=1,
opacity=1,
stroke=T,
popup=~text,
group="Top Crash Clusters") %>%
addCircles(data=police_all_sp,
stroke=F,
fillOpacity=0.4,
color="black",
weight=1,
group="Individual Crashes") %>%
addLayersControl(overlayGroups = c("Crash Clusters",
"Top Crash Clusters",
"Individual Crashes"),
options = layersControlOptions(collapsed = FALSE))
# Crash Clustering
# Parameters
near_crash_thresh_km <- 0.1
near_anycrash_in_cluster_thresh_km <- 0.3
# Load and Prep Data -----------------------------------------------------------
police_all_df <- read.csv(file.path(project_file_path, "Data", "FinalData", "Police Data", "police_digitized.csv"), stringsAsFactors=F)
# Remove obs with no coords and far away coords
police_all_df <- police_all_df[!is.na(police_all_df$latitude),]
police_all_df <- police_all_df[police_all_df$latitude > -2,]
police_all_df <- police_all_df[police_all_df$latitude < -1.1,]
police_all_df <- police_all_df[police_all_df$longitude < 37.5,]
# Sort by latitude & longitude
police_all_df <- police_all_df[order(police_all_df$latitude, police_all_df$longitude),]
# Clean Police Variables -------------------------------------------------------
police_all_df$fatal_injury_count[is.na(police_all_df$fatal_injury_count)] <- 0
police_all_df$serious_injury_count[is.na(police_all_df$serious_injury_count)] <- 0
police_all_df$slight_injury_count[is.na(police_all_df$slight_injury_count)] <- 0
police_all_df$injury_count <- police_all_df$slight_injury_count + police_all_df$serious_injury_count + police_all_df$fatal_injury_count
police_all_df$fatal_injury_pedestrian_count[is.na(police_all_df$fatal_injury_pedestrian_count)] <- 0
police_all_df$slight_injury_pedestrian_count[is.na(police_all_df$slight_injury_pedestrian_count)] <- 0
police_all_df$serious_injury_pedestrian_count[is.na(police_all_df$serious_injury_pedestrian_count)] <- 0
police_all_df$injury_pedestrian_count <- police_all_df$serious_injury_pedestrian_count + police_all_df$slight_injury_pedestrian_count + police_all_df$fatal_injury_pedestrian_count
police_all_df <- police_all_df[police_all_df$fatal_injury_pedestrian_count > 0,]
# Cluster ----------------------------------------------------------------------
police_all_df$id <- 1:nrow(police_all_df)
police_all_df$cluster_id <- NA
for(i in 1:nrow(police_all_df)){
police_all_df_i <- police_all_df[i,]
within_distance <- sqrt((police_all_df_i$longitude - police_all_df$longitude)^2 + (police_all_df_i$latitude - police_all_df$latitude)^2) <= (near_crash_thresh_km/111.12)
# If has a cluster ID, consider giving cluster id
if(!is.na(police_all_df_i$cluster_id)){
# Check if all crashes in cluster are within threshold distance
current_cluster <- police_all_df[police_all_df$cluster_id %in% police_all_df_i$cluster_id,]
within_cluster_distance <- sqrt((police_all_df_i$longitude - current_cluster$longitude)^2 + (police_all_df_i$latitude - current_cluster$latitude)^2) <= (near_anycrash_in_cluster_thresh_km/111.12)
# If a crash is not within thresh distance, give ID as cluster; otherwise, add to cluster
if(FALSE %in% within_cluster_distance){
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$cluster_id
}
# If doesn't have cluster ID, give ID.
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
}
}
# Create Cluster Polygons ------------------------------------------------------
police_all_sp <- police_all_df
coordinates(police_all_sp) <- ~longitude+latitude
crs(police_all_sp) <- CRS("+init=epsg:4326")
clusters_sp <- lapply(unique(police_all_sp$cluster_id), function(cluster_id_i){
police_all_sp_i <- police_all_sp[police_all_sp$cluster_id == cluster_id_i,]
police_all_sp_i_hull <- gConvexHull(police_all_sp_i)
police_all_sp_i_hull <- gBuffer(police_all_sp_i_hull, width=0.00001)
police_all_sp_i_hull$id <- cluster_id_i
police_all_sp_i_hull$N <- nrow(police_all_sp_i)
return(police_all_sp_i_hull)
}) %>% do.call(what="rbind")
# Leaflet Map ------------------------------------------------------------------
clusters_sp <- clusters_sp[clusters_sp$N > 1,]
clusters_sp$text <- clusters_sp$N %>% as.character
clusters_sp_top <- clusters_sp[order(clusters_sp$N, decreasing=T),][1:30,]
pal <- colorNumeric(
palette = "Spectral",
domain = clusters_sp$N,
reverse=T
)
leaflet() %>%
addProviderTiles(providers$Esri.WorldTopoMap) %>%
addPolygons(data=clusters_sp,
color = ~pal(N),
fillOpacity=.9,
opacity=0.8,
stroke=T,
popup=~text,
group="Crash Clusters") %>%
addPolygons(data=clusters_sp_top,
color = "red",
fillOpacity=1,
opacity=1,
stroke=T,
popup=~text,
group="Top Crash Clusters") %>%
addCircles(data=police_all_sp,
stroke=F,
fillOpacity=0.4,
color="black",
weight=1,
group="Individual Crashes") %>%
addLayersControl(overlayGroups = c("Crash Clusters",
"Top Crash Clusters",
"Individual Crashes"),
options = layersControlOptions(collapsed = FALSE))
# Import and Clean Video Counting Discrepency Data
# Import and Clean Data --------------------------------------------------------
#### Import Data
counting_sheet <- gs_title("counting_v2")
vehicle_counts <- counting_sheet %>% gs_read(ws = "Vehicle Videos")
pedestrian_counts <- counting_sheet %>% gs_read(ws = "Pedestrian Videos")
footbridge_counts <- counting_sheet %>% gs_read(ws = "Footbridge Videos")
#### Add Variable Names
names(vehicle_counts) <- vehicle_counts[1,] %>% str_replace_all("[[:punct:]]", "") %>% str_replace_all(" ", "_") %>% tolower
vehicle_counts <- vehicle_counts[-1,]
names(pedestrian_counts) <- pedestrian_counts[1,] %>% str_replace_all("[[:punct:]]", "") %>% str_replace_all(" ", "_") %>% tolower
pedestrian_counts <- pedestrian_counts[-1,]
names(footbridge_counts) <- footbridge_counts[1,] %>% str_replace_all("[[:punct:]]", "") %>% str_replace_all(" ", "_") %>% tolower
footbridge_counts <- footbridge_counts[-1,]
#### Add Unique ID
vehicle_counts$id <- paste0(vehicle_counts$video_name, "_", vehicle_counts$road_segment_id)
pedestrian_counts$id <- paste0(pedestrian_counts$video_name, "_", pedestrian_counts$road_segment_id)
footbridge_counts$id <- footbridge_counts$video_name
# Discrepencies ----------------------------------------------------------------
video_constant_vars <- c("video_name", "supervisor_doing_counting", "road_segment_id", "id")
pedestrian_constant_vars <- c("video_name", "supervisor_doing_counting", "road_segment_id", "id")
df = pedestrian_counts
id = pedestrian_counts$id[1]
constant_vars = pedestrian_constant_vars
long_to_wide <- function(id, df, constant_vars){
df_i <- df[df$id %in% id,]
coders_df <- lapply(1:nrow(df_i), function(i){
df_i <- df_i[i,]
df_i_constantvars <- df_i[,constant_vars]
df_i_datavars <- df_i[,!(names(df_i) %in% constant_vars)]
df_i_datavars$id <- df_i_constantvars$id
df_i_datavars <- df_i_datavars %>% gather('question', "value", -id)
df_out <- merge(df_i_datavars, df_i_constantvars, by="id")
names(df_out)[names(df_out) == "value"] <- paste0("value_", i)
names(df_out)[names(df_out) == "supervisor_doing_counting"] <- paste0("supervisor_doing_counting_", i)
return(df_out)
})
coders_merged <- merge(coders_df[[1]], coders_df[[2]], by=c("id", "video_name", "road_segment_id", "question"))
return(coders_merged)
}
vehicle_counts_df <- lapply(unique(vehicle_counts$id), long_to_wide, vehicle_counts, video_constant_vars) %>% bind_rows
pedestrian_counts_df <- lapply(unique(pedestrian_counts$id), long_to_wide, pedestrian_counts, pedestrian_constant_vars) %>% bind_rows
counts_df <- bind_rows(vehicle_counts_df, pedestrian_counts_df)
# Clean Values -----------------------------------------------------------------
# Video Duration
counts_df$value_1[vehicle_counts_df$question == "video_duration_minutes_and_seconds"] <-
counts_df$value_1[vehicle_counts_df$question == "video_duration_minutes_and_seconds"] %>%
lapply(function(str){
time_m_s <- str %>% strsplit(":") %>% unlist %>% as.numeric
time_m <- time_m_s[1] + time_m_s[2]/60
return(time_m)
}) %>% unlist
counts_df$value_2[vehicle_counts_df$question == "video_duration_minutes_and_seconds"] <-
counts_df$value_2[vehicle_counts_df$question == "video_duration_minutes_and_seconds"] %>%
lapply(function(str){
time_m_s <- str %>% strsplit(":") %>% unlist %>% as.numeric
time_m <- time_m_s[1] + time_m_s[2]/60
return(time_m)
}) %>% unlist
# Video Time of Day
counts_df$value_1[vehicle_counts_df$question == "video_time_of_day"] <-
counts_df$value_1[vehicle_counts_df$question == "video_time_of_day"] %>%
lapply(function(str){
time_m_s <- str %>% strsplit(":") %>% unlist %>% as.numeric
time_m <- time_m_s[1] + time_m_s[2]/60
return(time_m)
}) %>% unlist
counts_df$value_2[vehicle_counts_df$question == "video_time_of_day"] <-
counts_df$value_2[vehicle_counts_df$question == "video_time_of_day"] %>%
lapply(function(str){
time_m_s <- str %>% strsplit(":") %>% unlist %>% as.numeric
time_m <- time_m_s[1] + time_m_s[2]/60
return(time_m)
}) %>% unlist
# Check Discrepencies ----------------------------------------------------------
counts_df$value_1 <- as.numeric(counts_df$value_1)
counts_df$value_2 <- as.numeric(counts_df$value_2)
counts_df$value_1[is.na(counts_df$value_1)] <- 0
counts_df$value_2[is.na(counts_df$value_2)] <- 0
counts_df <- counts_df[!(counts_df$question %in% c("video_duration_minutes_and_seconds", "video_time_of_day")),]
counts_df$difference <- abs(counts_df$value_1 - counts_df$value_2)
View(counts_df)
table(table(counts_df$difference))
View(counts_df)
# Crash Clustering
# Parameters
near_crash_thresh_km <- 0.1
near_anycrash_in_cluster_thresh_km <- 0.3
# Load and Prep Data -----------------------------------------------------------
police_all_df <- read.csv(file.path(project_file_path, "Data", "FinalData", "Police Data", "police_digitized.csv"), stringsAsFactors=F)
# Remove obs with no coords and far away coords
police_all_df <- police_all_df[!is.na(police_all_df$latitude),]
police_all_df <- police_all_df[police_all_df$latitude > -2,]
police_all_df <- police_all_df[police_all_df$latitude < -1.1,]
police_all_df <- police_all_df[police_all_df$longitude < 37.5,]
# Sort by latitude & longitude
police_all_df <- police_all_df[order(police_all_df$latitude, police_all_df$longitude),]
# Clean Police Variables -------------------------------------------------------
police_all_df$fatal_injury_count[is.na(police_all_df$fatal_injury_count)] <- 0
police_all_df$serious_injury_count[is.na(police_all_df$serious_injury_count)] <- 0
police_all_df$slight_injury_count[is.na(police_all_df$slight_injury_count)] <- 0
police_all_df$injury_count <- police_all_df$slight_injury_count + police_all_df$serious_injury_count + police_all_df$fatal_injury_count
police_all_df$fatal_injury_pedestrian_count[is.na(police_all_df$fatal_injury_pedestrian_count)] <- 0
police_all_df$slight_injury_pedestrian_count[is.na(police_all_df$slight_injury_pedestrian_count)] <- 0
police_all_df$serious_injury_pedestrian_count[is.na(police_all_df$serious_injury_pedestrian_count)] <- 0
police_all_df$injury_pedestrian_count <- police_all_df$serious_injury_pedestrian_count + police_all_df$slight_injury_pedestrian_count + police_all_df$fatal_injury_pedestrian_count
#police_all_df <- police_all_df[police_all_df$fatal_injury_pedestrian_count > 0,]
# Cluster ----------------------------------------------------------------------
police_all_df$id <- 1:nrow(police_all_df)
police_all_df$cluster_id <- NA
for(i in 1:nrow(police_all_df)){
police_all_df_i <- police_all_df[i,]
within_distance <- sqrt((police_all_df_i$longitude - police_all_df$longitude)^2 + (police_all_df_i$latitude - police_all_df$latitude)^2) <= (near_crash_thresh_km/111.12)
# If has a cluster ID, consider giving cluster id
if(!is.na(police_all_df_i$cluster_id)){
# Check if all crashes in cluster are within threshold distance
current_cluster <- police_all_df[police_all_df$cluster_id %in% police_all_df_i$cluster_id,]
within_cluster_distance <- sqrt((police_all_df_i$longitude - current_cluster$longitude)^2 + (police_all_df_i$latitude - current_cluster$latitude)^2) <= (near_anycrash_in_cluster_thresh_km/111.12)
# If a crash is not within thresh distance, give ID as cluster; otherwise, add to cluster
if(FALSE %in% within_cluster_distance){
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$cluster_id
}
# If doesn't have cluster ID, give ID.
} else{
police_all_df$cluster_id[within_distance] <- police_all_df_i$id
}
}
# Create Cluster Polygons ------------------------------------------------------
police_all_sp <- police_all_df
coordinates(police_all_sp) <- ~longitude+latitude
crs(police_all_sp) <- CRS("+init=epsg:4326")
clusters_sp <- lapply(unique(police_all_sp$cluster_id), function(cluster_id_i){
police_all_sp_i <- police_all_sp[police_all_sp$cluster_id == cluster_id_i,]
police_all_sp_i_hull <- gConvexHull(police_all_sp_i)
police_all_sp_i_hull <- gBuffer(police_all_sp_i_hull, width=0.00001)
police_all_sp_i_hull$id <- cluster_id_i
police_all_sp_i_hull$N <- nrow(police_all_sp_i)
return(police_all_sp_i_hull)
}) %>% do.call(what="rbind")
# Leaflet Map ------------------------------------------------------------------
clusters_sp <- clusters_sp[clusters_sp$N > 1,]
clusters_sp$text <- clusters_sp$N %>% as.character
clusters_sp_top <- clusters_sp[order(clusters_sp$N, decreasing=T),][1:30,]
pal <- colorNumeric(
palette = "Spectral",
domain = clusters_sp$N,
reverse=T
)
leaflet() %>%
addProviderTiles(providers$Esri.WorldTopoMap) %>%
addPolygons(data=clusters_sp,
color = ~pal(N),
fillOpacity=.9,
opacity=0.8,
stroke=T,
popup=~text,
group="Crash Clusters") %>%
addPolygons(data=clusters_sp_top,
color = "red",
fillOpacity=1,
opacity=1,
stroke=T,
popup=~text,
group="Top Crash Clusters") %>%
addCircles(data=police_all_sp,
stroke=F,
fillOpacity=0.4,
color="black",
weight=1,
group="Individual Crashes") %>%
addLayersControl(overlayGroups = c("Crash Clusters",
"Top Crash Clusters",
"Individual Crashes"),
options = layersControlOptions(collapsed = FALSE))
nrow(clusters_sp)
table(clusters_sp$N > 10)
table(clusters_sp$N > 30)
